{"version":3,"sources":["webpack://nopun-ecs-basic-example/../dist/index.js","webpack://nopun-ecs-basic-example/../dist/internal/Entity.js","webpack://nopun-ecs-basic-example/../dist/internal/Filter.js","webpack://nopun-ecs-basic-example/../dist/internal/Query.js","webpack://nopun-ecs-basic-example/../dist/internal/Scene.js","webpack://nopun-ecs-basic-example/../dist/internal/System.js","webpack://nopun-ecs-basic-example/webpack/bootstrap","webpack://nopun-ecs-basic-example/./src/index.ts"],"names":["Object","defineProperty","exports","value","Not","System","Scene","Scene_1","enumerable","get","System_1","Filter_1","AttemptToGetUnassignedComponent","AttemptToRemoveUnassignedComponent","AttemptToUpdateUnassignedComponent","AttemptToAssignDuplicateComponent","EntityError","Entity","scene","updateQueue","this","componentsStore","Map","childrenStore","Set","children","self","store","create","child","entities","add","CC","initialValue","has","component","assign","set","queueForUpdate","overwriteValue","builderFn","delete","Error","message","super","entity","name","Negation","subject","cc","Query","filter","all","added","removed","unchanged","writer","query","remove","matches","update","flush","clear","reader","size","every","f","AttemptToUpdateUnknownOrForeignEntity","AttemptToDestroyUnknownOrForeignEntity","AttemptToUnregisterUnknownSystem","AttemptToRegisterDuplicateSystem","AttemptToGetResourceThatDoesNotExist","AttemptToRemoveResourceThatDoesNotExist","AttemptToAddResourceThatAlreadyExists","AttemptToAttachSceneToItself","AttemptToAttachSceneThatIsAlreadyAttachedElsewhere","AttemptToCreateCircularReference","AttemptToDetachUnattachedScene","AttemptToAttachDuplicateScene","SceneError","Query_1","Entity_1","parent","debug","result","scenesStore","scenes","resourcesStore","systemsStore","entitiesStore","attach","detach","resources","RC","resource","systems","register","SC","queries","queryReaders","key","entries","push","system","container","SystemContainer","initialize","unregister","destroy","entitiesThatNeedTobeUpdated","entityUpdateQueue","queue","exists","deltaTime","execute","parentScene","childScene","constructor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","__webpack_modules__","Position2D","x","y","Velocity2D","vx","vy","DOMNodeReference","InputSystem","keysPressed","document","addEventListener","event","movable","movables","velocity","MovementSystem","dt","position","ObjectsRenderer","renderable","renderables","node","style","transform","getElementById","start","Date","now","run","current","delta","requestAnimationFrame"],"mappings":"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","file":"main.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Not = exports.System = exports.Scene = void 0;\nvar Scene_1 = require(\"./internal/Scene\");\nObject.defineProperty(exports, \"Scene\", { enumerable: true, get: function () { return Scene_1.Scene; } });\nvar System_1 = require(\"./internal/System\");\nObject.defineProperty(exports, \"System\", { enumerable: true, get: function () { return System_1.System; } });\nvar Filter_1 = require(\"./internal/Filter\");\nObject.defineProperty(exports, \"Not\", { enumerable: true, get: function () { return Filter_1.Not; } });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AttemptToGetUnassignedComponent = exports.AttemptToRemoveUnassignedComponent = exports.AttemptToUpdateUnassignedComponent = exports.AttemptToAssignDuplicateComponent = exports.EntityError = exports.Entity = void 0;\nclass Entity {\n    constructor(scene, updateQueue) {\n        this.scene = scene;\n        this.updateQueue = updateQueue;\n        this.componentsStore = new Map();\n        this.childrenStore = new Set();\n        this.children = (() => {\n            const self = this;\n            const store = this.childrenStore;\n            function create() {\n                const child = self.scene.entities.create();\n                store.add(child);\n                return child;\n            }\n            return { create };\n        })();\n    }\n    add(CC, initialValue = {}) {\n        if (this.componentsStore.has(CC))\n            throw new AttemptToAssignDuplicateComponent(this, CC);\n        const component = new CC();\n        Object.assign(component, initialValue);\n        this.componentsStore.set(CC, component);\n        this.updateQueue.queueForUpdate(this);\n        return this;\n    }\n    update(CC, overwriteValue) {\n        if (!this.componentsStore.has(CC))\n            throw new AttemptToUpdateUnassignedComponent(this, CC);\n        const component = this.componentsStore.get(CC);\n        Object.assign(component, overwriteValue);\n        return this;\n    }\n    build(builderFn) {\n        return builderFn(this);\n    }\n    remove(CC) {\n        if (!this.componentsStore.has(CC))\n            throw new AttemptToRemoveUnassignedComponent(this, CC);\n        this.componentsStore.delete(CC);\n        this.updateQueue.queueForUpdate(this);\n        return this;\n    }\n    has(CC) {\n        return this.componentsStore.has(CC);\n    }\n    get(CC) {\n        if (!this.componentsStore.has(CC))\n            throw new AttemptToGetUnassignedComponent(this, CC);\n        return this.componentsStore.get(CC);\n    }\n}\nexports.Entity = Entity;\nclass EntityError extends Error {\n    constructor(message) {\n        super(`[EntityError]: ${message}`);\n    }\n}\nexports.EntityError = EntityError;\nclass AttemptToAssignDuplicateComponent extends EntityError {\n    constructor(entity, CC) {\n        super(`Component \"${CC.name}\" cannot be assigned to entity, ` +\n            `because the entity already has a component \"${CC.name}\".`);\n        this.entity = entity;\n        this.CC = CC;\n    }\n}\nexports.AttemptToAssignDuplicateComponent = AttemptToAssignDuplicateComponent;\nclass AttemptToUpdateUnassignedComponent extends EntityError {\n    constructor(entity, CC) {\n        super(`Component \"${CC.name}\" cannot be updated for entity, ` +\n            `because the entity has no component \"${CC.name}\".`);\n        this.entity = entity;\n        this.CC = CC;\n    }\n}\nexports.AttemptToUpdateUnassignedComponent = AttemptToUpdateUnassignedComponent;\nclass AttemptToRemoveUnassignedComponent extends EntityError {\n    constructor(entity, CC) {\n        super(`Component \"${CC.name}\" cannot be removed from entity, ` +\n            `because the entity has no component \"${CC.name}\".`);\n        this.entity = entity;\n        this.CC = CC;\n    }\n}\nexports.AttemptToRemoveUnassignedComponent = AttemptToRemoveUnassignedComponent;\nclass AttemptToGetUnassignedComponent extends EntityError {\n    constructor(entity, CC) {\n        super(`Component \"${CC.name}\" cannot be obtained from entity, ` +\n            `because the entity has no component \"${CC.name}\".`);\n        this.entity = entity;\n        this.CC = CC;\n    }\n}\nexports.AttemptToGetUnassignedComponent = AttemptToGetUnassignedComponent;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Not = exports.Negation = void 0;\nclass Negation {\n    constructor(subject) {\n        this.subject = subject;\n    }\n}\nexports.Negation = Negation;\nfunction Not(cc) {\n    return new Negation(cc);\n}\nexports.Not = Not;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Query = void 0;\nconst Filter_1 = require(\"./Filter\");\nclass Query {\n    constructor(filter) {\n        this.filter = filter;\n        this.all = new Set();\n        this.added = new Set();\n        this.removed = new Set();\n        this.unchanged = new Set();\n        this.writer = (() => {\n            const query = this;\n            function add(entity) {\n                if (query.matches(entity) && !query.all.has(entity)) {\n                    query.all.add(entity);\n                    query.added.add(entity);\n                }\n            }\n            function update(entity) {\n                if (query.matches(entity)) {\n                    if (!query.all.has(entity)) {\n                        query.all.add(entity);\n                        query.added.add(entity);\n                    }\n                }\n                else\n                    remove(entity);\n            }\n            function remove(entity) {\n                query.all.delete(entity);\n                query.added.delete(entity);\n                query.unchanged.delete(entity);\n                if (query.matches(entity))\n                    query.removed.add(entity);\n            }\n            function flush() {\n                for (const entity of query.added) {\n                    query.unchanged.add(entity);\n                }\n                query.added.clear();\n                query.removed.clear();\n            }\n            return { add, update, remove, flush };\n        })();\n        this.reader = (() => {\n            const query = this;\n            function has(entity) {\n                return query.all.has(entity);\n            }\n            return {\n                get count() { return query.all.size; },\n                all: query.all,\n                added: query.added,\n                removed: query.removed,\n                unchanged: query.unchanged,\n                has\n            };\n        })();\n    }\n    matches(entity) {\n        return this.filter.every(f => {\n            if (f instanceof Filter_1.Negation) {\n                return !entity.has(f.subject);\n            }\n            else {\n                return entity.has(f);\n            }\n        });\n    }\n}\nexports.Query = Query;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AttemptToUpdateUnknownOrForeignEntity = exports.AttemptToDestroyUnknownOrForeignEntity = exports.AttemptToUnregisterUnknownSystem = exports.AttemptToRegisterDuplicateSystem = exports.AttemptToGetResourceThatDoesNotExist = exports.AttemptToRemoveResourceThatDoesNotExist = exports.AttemptToAddResourceThatAlreadyExists = exports.AttemptToAttachSceneToItself = exports.AttemptToAttachSceneThatIsAlreadyAttachedElsewhere = exports.AttemptToCreateCircularReference = exports.AttemptToDetachUnattachedScene = exports.AttemptToAttachDuplicateScene = exports.SceneError = exports.Scene = void 0;\nconst System_1 = require(\"./System\");\nconst Query_1 = require(\"./Query\");\nconst Entity_1 = require(\"./Entity\");\nclass Scene {\n    constructor() {\n        this.parent = null;\n        this.debug = (() => {\n            const self = this;\n            return {\n                get scenes() {\n                    let result = 1;\n                    for (const scene of self.scenesStore) {\n                        result += scene.debug.scenes;\n                    }\n                    return result;\n                },\n                get resources() {\n                    return self.resourcesStore.size;\n                },\n                get systems() {\n                    return self.systemsStore.size;\n                },\n                get entities() {\n                    return self.entitiesStore.size;\n                }\n            };\n        })();\n        this.scenesStore = new Set();\n        this.scenes = (() => {\n            const self = this;\n            const store = this.scenesStore;\n            function attach(scene) {\n                if (scene === self)\n                    throw new AttemptToAttachSceneToItself(scene);\n                else if (store.has(scene))\n                    throw new AttemptToAttachDuplicateScene(self, scene);\n                else if (scene.parent !== null)\n                    throw new AttemptToAttachSceneThatIsAlreadyAttachedElsewhere(self, scene);\n                else {\n                    let parent = self.parent;\n                    while (parent !== null) {\n                        if (parent === scene)\n                            throw new AttemptToCreateCircularReference(self, scene);\n                        parent = parent.parent;\n                    }\n                    scene.parent = self;\n                }\n                store.add(scene);\n            }\n            function detach(scene) {\n                if (store.has(scene)) {\n                    scene.parent = null;\n                    return store.delete(scene);\n                }\n                else\n                    throw new AttemptToDetachUnattachedScene(self, scene);\n            }\n            return { attach, detach };\n        })();\n        this.resourcesStore = new Map();\n        this.resources = (() => {\n            const self = this;\n            const store = this.resourcesStore;\n            function add(RC, initialValue = {}) {\n                if (store.has(RC))\n                    throw new AttemptToAddResourceThatAlreadyExists(self, RC);\n                const resource = new RC();\n                Object.assign(resource, initialValue);\n                store.set(RC, resource);\n                return resource;\n            }\n            function remove(RC) {\n                if (!store.has(RC))\n                    throw new AttemptToRemoveResourceThatDoesNotExist(self, RC);\n                store.delete(RC);\n            }\n            function get(RC) {\n                if (!store.has(RC))\n                    throw new AttemptToGetResourceThatDoesNotExist(self, RC);\n                return store.get(RC);\n            }\n            return { add, remove, get };\n        })();\n        this.systemsStore = new Map();\n        this.systems = (() => {\n            const self = this;\n            const store = this.systemsStore;\n            function register(SC) {\n                if (store.has(SC))\n                    throw new AttemptToRegisterDuplicateSystem(self, SC);\n                let queries = [];\n                let queryReaders = {};\n                for (const [key, filter] of Object.entries(SC.queries)) {\n                    const query = new Query_1.Query(filter);\n                    queries.push(query);\n                    queryReaders[key] = query.reader;\n                }\n                const system = new SC(self, queryReaders);\n                const container = new System_1.SystemContainer(system, queries);\n                store.set(SC, container);\n                system.initialize();\n            }\n            function unregister(SC) {\n                if (!store.has(SC))\n                    throw new AttemptToUnregisterUnknownSystem(self, SC);\n                const { system } = store.get(SC);\n                store.delete(SC);\n                system.destroy();\n            }\n            return { register, unregister };\n        })();\n        this.entitiesThatNeedTobeUpdated = new Set();\n        this.entityUpdateQueue = (() => {\n            const self = this;\n            const queue = this.entitiesThatNeedTobeUpdated;\n            function queueForUpdate(entity) {\n                if (!self.entities.exists(entity)) {\n                    throw new AttemptToUpdateUnknownOrForeignEntity(self, entity);\n                }\n                queue.add(entity);\n            }\n            return { queueForUpdate };\n        })();\n        this.entitiesStore = new Set();\n        this.entities = (() => {\n            const self = this;\n            const store = this.entitiesStore;\n            function create() {\n                const entity = new Entity_1.Entity(self, self.entityUpdateQueue);\n                store.add(entity);\n                return entity;\n            }\n            function exists(entity) {\n                return store.has(entity);\n            }\n            function destroy(entity) {\n                if (!store.has(entity))\n                    throw new AttemptToDestroyUnknownOrForeignEntity(self, entity);\n                store.delete(entity);\n                // @TODO: This is ugly, but `childrenStore` is not supposed to be\n                // public API, so I'm fine with circumventing the type system\n                // at this point.\n                for (const child of entity.childrenStore) {\n                    if (store.has(child)) {\n                        self.entities.destroy(child);\n                    }\n                }\n                entity.childrenStore.clear();\n                for (const [, { queries }] of self.systemsStore) {\n                    for (const query of queries) {\n                        query.writer.remove(entity);\n                    }\n                }\n                self.entitiesThatNeedTobeUpdated.delete(entity);\n            }\n            return { create, exists, destroy };\n        })();\n        this.initialize();\n    }\n    initialize() { }\n    destroy() {\n        for (const [, { system }] of this.systemsStore) {\n            system.destroy();\n        }\n    }\n    execute(deltaTime) {\n        for (const [, { queries }] of this.systemsStore) {\n            for (const query of queries) {\n                query.writer.flush();\n            }\n        }\n        for (const [, { system }] of this.systemsStore) {\n            for (const entity of this.entitiesThatNeedTobeUpdated) {\n                for (const [, { queries }] of this.systemsStore) {\n                    for (const query of queries) {\n                        query.writer.update(entity);\n                    }\n                }\n            }\n            this.entitiesThatNeedTobeUpdated.clear();\n            system.execute(deltaTime);\n        }\n        for (const scene of this.scenesStore) {\n            scene.execute(deltaTime);\n        }\n    }\n}\nexports.Scene = Scene;\nclass SceneError extends Error {\n    constructor(message) {\n        super(`[SceneError]: ${message}`);\n    }\n}\nexports.SceneError = SceneError;\nclass AttemptToAttachDuplicateScene extends SceneError {\n    constructor(parentScene, childScene) {\n        super(`Scene \"${childScene.constructor.name}\" cannot be added ` +\n            `to \"${parentScene.constructor.name}\", because \"${parentScene.constructor.name}\" ` +\n            `already has scene \"${childScene.constructor.name}\".`);\n        this.parentScene = parentScene;\n        this.childScene = childScene;\n    }\n}\nexports.AttemptToAttachDuplicateScene = AttemptToAttachDuplicateScene;\nclass AttemptToDetachUnattachedScene extends SceneError {\n    constructor(parentScene, childScene) {\n        super(`Scene \"${childScene.constructor.name}\" cannot be removed ` +\n            `from \"${parentScene.constructor.name}\", because \"${parentScene.constructor.name}\" ` +\n            `has no scene \"${childScene.constructor.name}\".`);\n        this.parentScene = parentScene;\n        this.childScene = childScene;\n    }\n}\nexports.AttemptToDetachUnattachedScene = AttemptToDetachUnattachedScene;\nclass AttemptToCreateCircularReference extends SceneError {\n    constructor(parentScene, childScene) {\n        super(`Scene \"${childScene.constructor.name}\" cannot be added ` +\n            `to \"${parentScene.constructor.name}\", because this would create ` +\n            `a circular reference`);\n        this.parentScene = parentScene;\n        this.childScene = childScene;\n    }\n}\nexports.AttemptToCreateCircularReference = AttemptToCreateCircularReference;\nclass AttemptToAttachSceneThatIsAlreadyAttachedElsewhere extends SceneError {\n    constructor(parentScene, childScene) {\n        super(`Scene \"${childScene.constructor.name}\" cannot be added ` +\n            `to \"${parentScene.constructor.name}\", because \"${parentScene.constructor.name}\" ` +\n            `already belongs to another scene.`);\n        this.parentScene = parentScene;\n        this.childScene = childScene;\n    }\n}\nexports.AttemptToAttachSceneThatIsAlreadyAttachedElsewhere = AttemptToAttachSceneThatIsAlreadyAttachedElsewhere;\nclass AttemptToAttachSceneToItself extends SceneError {\n    constructor(scene) {\n        super(`Scene \"${scene.constructor.name}\" cannot be added to itself.`);\n        this.scene = scene;\n    }\n}\nexports.AttemptToAttachSceneToItself = AttemptToAttachSceneToItself;\nclass AttemptToAddResourceThatAlreadyExists extends SceneError {\n    constructor(scene, RC) {\n        super(`Resource \"${RC.name}\" cannot be added ` +\n            `to \"${scene.constructor.name}\", because \"${scene.constructor.name}\" ` +\n            `already has resource \"${RC.name}\".`);\n        this.scene = scene;\n        this.RC = RC;\n    }\n}\nexports.AttemptToAddResourceThatAlreadyExists = AttemptToAddResourceThatAlreadyExists;\nclass AttemptToRemoveResourceThatDoesNotExist extends SceneError {\n    constructor(scene, RC) {\n        super(`Resource \"${RC.name}\" cannot be removed ` +\n            `from \"${scene.constructor.name}\", because \"${scene.constructor.name}\" ` +\n            `has no resource \"${RC.name}\".`);\n        this.scene = scene;\n        this.RC = RC;\n    }\n}\nexports.AttemptToRemoveResourceThatDoesNotExist = AttemptToRemoveResourceThatDoesNotExist;\nclass AttemptToGetResourceThatDoesNotExist extends SceneError {\n    constructor(scene, RC) {\n        super(`Resource \"${RC.name}\" cannot be retrieved ` +\n            `from \"${scene.constructor.name}\", because \"${scene.constructor.name}\" ` +\n            `has no resource \"${RC.name}\".`);\n        this.scene = scene;\n        this.RC = RC;\n    }\n}\nexports.AttemptToGetResourceThatDoesNotExist = AttemptToGetResourceThatDoesNotExist;\nclass AttemptToRegisterDuplicateSystem extends SceneError {\n    constructor(scene, SC) {\n        super(`System \"${SC.name}\" cannot be registered ` +\n            `to \"${scene.constructor.name}\", because \"${scene.constructor.name}\" ` +\n            `already has a registered system \"${SC.name}\".`);\n        this.scene = scene;\n        this.SC = SC;\n    }\n}\nexports.AttemptToRegisterDuplicateSystem = AttemptToRegisterDuplicateSystem;\nclass AttemptToUnregisterUnknownSystem extends SceneError {\n    constructor(scene, SC) {\n        super(`System \"${SC.name}\" cannot be unregisterend ` +\n            `from \"${scene.constructor.name}\", because \"${scene.constructor.name}\" ` +\n            `does not have a registered system \"${SC.name}\".`);\n        this.scene = scene;\n        this.SC = SC;\n    }\n}\nexports.AttemptToUnregisterUnknownSystem = AttemptToUnregisterUnknownSystem;\nclass AttemptToDestroyUnknownOrForeignEntity extends SceneError {\n    constructor(scene, entity) {\n        super(`Entity cannot be destroyed ` +\n            `by \"${scene.constructor.name}\", because ` +\n            `it was not created by \"${scene.constructor.name}\".`);\n        this.scene = scene;\n        this.entity = entity;\n    }\n}\nexports.AttemptToDestroyUnknownOrForeignEntity = AttemptToDestroyUnknownOrForeignEntity;\nclass AttemptToUpdateUnknownOrForeignEntity extends SceneError {\n    constructor(scene, entity) {\n        super(`Entity cannot be updated ` +\n            `by \"${scene.constructor.name}\", because ` +\n            `it was not created by \"${scene.constructor.name}\".`);\n        this.scene = scene;\n        this.entity = entity;\n    }\n}\nexports.AttemptToUpdateUnknownOrForeignEntity = AttemptToUpdateUnknownOrForeignEntity;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SystemContainer = exports.System = void 0;\nclass System {\n    constructor(scene, queries) {\n        this.scene = scene;\n        this.queries = queries;\n    }\n    initialize() { }\n    destroy() { }\n}\nexports.System = System;\nSystem.queries = {};\nclass SystemContainer {\n    constructor(system, queries) {\n        this.system = system;\n        this.queries = queries;\n    }\n}\nexports.SystemContainer = SystemContainer;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// Actually: import { System, Scene } from \"nopun-ecs\";\nimport { System, Scene } from \"../../../dist\";\n\n/* COMPONENTS */\nclass Position2D {\n    // Components are just plain objects that hold data\n    x: number = 0;\n    y: number = 0;\n}\n\nclass Velocity2D {\n    // Strictly speaking, Velocity2D is just a 2D Vector,\n    // just like Position2D. But since components are identified\n    // by their classes and an entity can only hold one component\n    // instance per component class, we do not re-use classes at\n    // this point.\n    //\n    // I even chose to give the properties of Velocity2D different\n    // names from those of Position2D, because in my experience\n    // this makes both components easier to use later on.\n    vx: number = 0;\n    vy: number = 0;\n}\n\nclass DOMNodeReference {\n    // We are going to need a reference to the dom node we set up\n    // in our HTML file, in order to manipulate it later on.\n    node: HTMLElement;\n}\n\n/* SYSTEMS */\nclass InputSystem extends System {\n    // Every system can provide a static `queries` property that contains\n    // a hashmap of filter arrays. The results of these queries will be\n    // available under e.g. `this.queries.movables` in the execute method\n    // of the system.\n    static queries = {\n        // We want every entity, that has a `Velocity2D` component.\n        movables: [Velocity2D]\n    };\n\n    // Here we are going to store all key presses. Doing so is not\n    // ECS-specific but specific to this example.\n    private readonly keysPressed = new Set<string>();\n\n    // Every system can provide an `initialize` method, which will be called\n    // whenever a system is registered to a scene. We'll use this method\n    // do register our DOM event handlers.\n    initialize() {\n        document.addEventListener(\"keydown\", (event: KeyboardEvent) => {\n            // Add the pressed key to our set\n            this.keysPressed.add(event.key);\n        });\n\n        document.addEventListener(\"keyup\", (event: KeyboardEvent) => {\n            // Remove the released key from our set\n\t\t\tthis.keysPressed.delete(event.key);\n        });\n    }\n\n    // Every system must provide an `execute` method. here's where we\n    // implement our logic. `execute` is called on every frame in our\n    // game, so at 60fps it is called 60 times per second.\n    execute() {\n        // We loop through the query results of the movables query we\n        // defined above.\n        for (const movable of this.queries.movables.all) {\n            // This is how we can access the data stored in the\n            // `Velocity2D` component of our movable entity.\n            const velocity = movable.get(Velocity2D);\n\n            if (this.keysPressed.has(\"ArrowUp\")) {\n                velocity.vy = -1;\n            } else if (this.keysPressed.has(\"ArrowDown\")) {\n                velocity.vy = 1;\n            } else {\n                velocity.vy = 0;\n            }\n\n            if (this.keysPressed.has(\"ArrowLeft\")) {\n                velocity.vx = -1;\n            } else if (this.keysPressed.has(\"ArrowRight\")) {\n                velocity.vx = 1;\n            } else  {\n                velocity.vx = 0;\n            }\n        }\n    }\n}\n\nclass MovementSystem extends System {\n    static queries = {\n        // Now we want every entity, that has a `Velocity2D` and a\n        // `Position2D` component.\n        movables: [Velocity2D, Position2D]\n    };\n\n    // The execute method always receives the current frame delta time,\n    // which allows us to calculate stable movement regardless of the\n    // underlying performance.\n    //\n    // For more on that see: https://medium.com/@dr3wc/understanding-delta-time-b53bf4781a03\n    execute(dt: number) {\n        for (const movable of this.queries.movables.all) {\n            // We retrieve both velocity and position from our\n            // entities\n            const position = movable.get(Position2D);\n            const velocity = movable.get(Velocity2D);\n\n            // And then we update the position based on the\n            // velocity\n            position.x += dt * velocity.vx;\n            position.y += dt * velocity.vy;\n        }\n    }\n}\n\nclass ObjectsRenderer extends System {\n    static queries = {\n        // This system can render any entity that has a `Position2D`\n        // and a `DOMNodeReference` component\n        renderables: [Position2D, DOMNodeReference]\n    };\n\n    execute() {\n        for (const renderable of this.queries.renderables.all) {\n            const { x, y } = renderable.get(Position2D);\n            const { node } = renderable.get(DOMNodeReference);\n\n            // Sync position with our DOM node styles. We're using transforms\n            // here, because it should be more performant - but we shouldn't\n            // rely on DOM rendering in any performance-critical scenario\n            // anyway. This is just for demo purposes!\n            node.style.transform = `translateX(${x}px) translateY(${y}px)`;\n        }\n    }\n}\n\nconst scene = new Scene();\n\n// The order in which we register our systems matters. Systems are\n// executed in the order they've been registered.\nscene.systems.register(InputSystem);\nscene.systems.register(MovementSystem);\nscene.systems.register(ObjectsRenderer);\n\n// Now we create our entity and apply our components to it.\nscene.entities.create()\n    .add(Position2D)\n    .add(Velocity2D)\n    .add(DOMNodeReference, {\n        // We can initialize components upon adding them\n        node: document.getElementById('object')!\n\t});\n\n// We need to calculate the delta time on our own, so\n// we capture the timestamp at the beginning\nlet start = Date.now();\nfunction run() {\n    const current = Date.now();\n    const delta = current - start; // Manual calculation of delta\n    start = current;\n\n    // Execute the scene - this will call the execute method of\n    // all systems in sequence.\n    scene.execute(delta);\n\n    // Continue the loop on the next animation frame\n    requestAnimationFrame(run);\n}\n\nrun();\n"],"sourceRoot":""}